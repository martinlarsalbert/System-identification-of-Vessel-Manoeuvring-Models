"""
This is a boilerplate pipeline 'kvlcc2'
generated using Kedro 0.17.6
"""

import pandas as pd
import numpy as np
from src.prime_system import PrimeSystem


def load(df: pd.DataFrame, ship_data: dict) -> pd.DataFrame:
    """load kvlcc2 data and transform it

    Parameters
    ----------
    df : pd.DataFrame
        kvlcc2 data

    Returns
    -------
    pd.DataFrame
        With correct column naming and radians etc.
    """

    df.dropna(how="all", inplace=True)

    mask = df["time"].diff() != 0
    df = df.loc[mask]
    df.set_index("time", inplace=True)
    df.sort_index(inplace=True)
    df.index = pd.to_timedelta(df.index, unit="s")
    df = df.resample("0.1S").interpolate().resample("2S").mean()
    scale_factor = ship_data["scale_factor"]
    df.index = df.index.total_seconds() / np.sqrt(scale_factor)

    angles = ["phi", "psi", "r", "delta"]
    df[angles] = np.deg2rad(df[angles])

    df.rename(
        columns={"u": "dx0", "v": "dy0"}, inplace=True
    )  # I checked that u,v, are not in ship coordinates.

    ## To model scale:
    df["x0"] /= scale_factor
    df["y0"] /= scale_factor
    df["dx0"] /= np.sqrt(scale_factor)
    df["dy0"] /= np.sqrt(scale_factor)
    df["p"] *= np.sqrt(scale_factor)
    df["r"] *= np.sqrt(scale_factor)
    df["rev"] *= 1 / 60 * np.sqrt(scale_factor)  # [rps]
    df["thrust"] = 0  # not true...
    df["V"] = np.sqrt(df["dx0"] ** 2 + df["dy0"] ** 2)

    dx = df["dx0"]
    dy = df["dy0"]
    psi = df["psi"]

    df["u"] = dx * np.cos(psi) + dy * np.sin(psi)
    df["v"] = -dx * np.sin(psi) + dy * np.cos(psi)

    return df


def fit_propeller_characteristics(open_water_characteristics: pd.DataFrame) -> dict:
    p = np.polyfit(
        x=open_water_characteristics.index, y=open_water_characteristics["Kt"], deg=2
    )
    propeller_coefficients = pd.Series(data=p, index=["k_2", "k_1", "k_0"])
    propeller_coefficients_dict = {
        key: float(value) for key, value in propeller_coefficients.items()
    }

    return propeller_coefficients_dict


def calculate_thrust(
    df: pd.DataFrame,
    ship_data: dict,
    propeller_coefficients: dict,
) -> pd.DataFrame:

    u = df["u"]
    v = df["v"]
    r = df["r"]

    n = df["rev"]
    D = ship_data["D"]

    """
    Yasukawa, H., Yoshimura, Y., 2015. Introduction of MMG standard method for ship maneuvering predictions. J Mar Sci Technol 20, 37–52. https://doi.org/10.1007/s00773-014-0293-y
    """

    beta = -np.arctan2(v, u)

    ps = PrimeSystem(**ship_data)
    xp_prime = ps._prime(
        ship_data["x_p"],
        unit="length",
    )
    r_prime = ps._prime(r, unit="angular_velocity", U=df["V"])
    beta_p = beta - xp_prime * r_prime

    w0 = ship_data["w_p0"]
    C_1 = ship_data["C_1"]
    C_2 = np.where(beta_p > 0, ship_data["C_2_beta_p_pos"], ship_data["C_2_beta_p_neg"])
    w = 1 - (1 - w0) * (1 + (1 - np.exp(-C_1 * np.abs(beta_p))) * (C_2 - 1))
    J = u * (1 - w) / (n * D)

    """
    Dai, K., Li, Y., 2019. Manoeuvring Prediction of KVLCC2 with Hydrodynamic Derivatives Generated by a Virtual Captive Model Test. Polish Maritime Research 26, 16–26. https://doi.org/10.2478/pomr-2019-0062
    """

    coefficients = np.flipud(list(propeller_coefficients.values()))
    Kt = np.polyval(p=coefficients, x=J)
    rho = ship_data["rho"]
    df["thrust"] = rho * n ** 2 * D ** 4 * Kt

    return df
